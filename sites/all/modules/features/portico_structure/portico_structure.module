<?php
/**
 * @file
 * Code for the Portico Structure feature.
 */

include_once 'portico_structure.features.inc';
include_once 'includes/portico_structure.block.inc';
include_once 'includes/portico_structure.admin.inc';

function portico_structure_admin_paths_alter(&$paths) {
  // Treat all user pages as administrative.
  $paths ['user']   = TRUE;
  $paths ['user/*'] = TRUE;
}

/**
 * Implements hook_menu().
 */
function portico_structure_menu() {

  $items['admin/content/portico'] = array(
    'title' => t('Portico'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('portico_config'),
    'access arguments' => array('administer configuration'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['sermon/autocomplete'] = array(
    'title' => 'Autocomplete for sermons',
    'page callback' => '_sermons_autocomplete',
    'access arguments' => array('administer configuration'),
    'type' => MENU_CALLBACK
  );
  return $items;
}

/**
 * [portico_structure_subtype_options description]
 * @param  [type] &$form       [description]
 * @param  [type] &$form_state [description]
 * @return [type]              [description]
 */
function portico_structure_subtype_options(&$form, &$form_state) {
  switch($form_state['bundle']) {
    case 'page' :
      $options = array(
        'sermons' => t('Sermons'),
        'leadership' => t('Leadership'),
      );
      break;
  }

  drupal_alter('subtype_options', $options, $form_state);

  return $options;
}

/**
 * Helper function that returns first node that meets the subtype argument.
 *
 * @param  string $subtype
 * @param  string $bundle
 * @return node object
 */
function portico_structure_get_subtype($subtype, $bundle = NULL) {
  if (empty($subtype)) {
    return FALSE;
  }
  // Now check for bundle, if empty set as landing.
  if (empty($bundle)) {
    $bundle = 'page';
  }

  $efq = new EntityFieldQuery();
  $efq->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', $bundle)
      ->propertyCondition('status', NODE_PUBLISHED)
      ->fieldCondition('field_subtype', 'value', $subtype, '=')
      ->addTag('portico_structure_get_subtype');

  $result = $efq->execute();

  if (empty($result['node'])) {
    return FALSE;
  }

  $result_node = reset($result['node']);
  $node = node_load($result_node->nid);
  return $node;
}

/**
 * Featured Sermon autocomplete
 * @param  [type] $string [description]
 * @return [type]         [description]
 */
function _sermons_autocomplete($string) {
  $matches = array();
  $result = db_select('node', 'n')
    ->condition('type', 'sermon')
    ->fields('n', array('title', 'nid'))
    ->condition('title', '%' . db_like($string) . '%', 'LIKE')
    ->execute();

  // save the query to matches
  foreach ($result as $row) {
    $matches[$row->title . ' [' . $row->nid . ']'] = check_plain($row->title) ;
  }

  // Return the result to the form in json
  drupal_json_output($matches);
}

/**
 * [portico_structure_preprocess_entity description]
 * @param  [type] &$variables [description]
 * @param  [type] $hook       [description]
 * @return [type]             [description]
 */
function portico_structure_preprocess_entity(&$variables, $hook) {
  $function = __FUNCTION__ . '_' . $variables['entity_type'];
  if (function_exists($function)) {
    $function($variables, $hook);
  }
}

/**
 * [portico_structure_preprocess_entity_paragraphs_item description]
 * @param  [type] &$vars [description]
 * @return [type]        [description]
 */
function portico_structure_preprocess_entity_paragraphs_item(&$vars) {
  // Reset all classes on paragraph items.
  $vars['classes_array'] = array(
    'paragraphs-item-' . drupal_html_class($vars['elements']['#bundle'])
  );

  switch ($vars['elements']['#bundle']) {

    case 'grid':

      if (empty($vars['paragraphs_item']->field_columns)) {
        return $vars;
      }
      $vars['classes_array'][] = 'columns-' .
        $vars['paragraphs_item']->field_columns['und'][0]['value'];
      break;
  }
}

/**
 * [portico_structure_preprocess_paragraphs_items description]
 * @param  [type] &$variables [description]
 * @return [type]             [description]
 */
function portico_structure_preprocess_paragraphs_items(&$variables) {
  $element = $variables['element'];
  $variables['classes_array'] = array(
    'wrapper-' . drupal_html_class($element['#field_name'])
  );
}

/**
 * Implementation of hook_entity_view_alter().
 */
function portico_structure_entity_view_alter(&$build, $type) {
  if ($type == 'node' && $build['#bundle'] == 'page') {
    if ($subtype = field_get_items('node', $build['#node'], 'field_subtype')) {

      switch($subtype[0]['value']) {
        case 'sermons':
          portico_structure_add_sermons($build);
          break;

        case 'leadership':
          portico_structure_add_leadership($build);
          break;
      }
    }
  }
}

/**
 * [portico_structure_add_sermons description]
 * @param  [type] &$build [description]
 * @return [type]         [description]
 */
function portico_structure_add_sermons(&$build) {

  $q = new EntityFieldQuery;
  $q->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'sermon')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->pager(0,10)
    ->propertyOrderBy('created', 'DESC')
    ->addTag('portico_structure_sermons');

  $r = $q->execute();

  if (empty($r['node'])) {
    return FALSE;
  }

  $nodes = entity_load('node', array_keys($r['node']));

  $viewed = entity_view('node', $nodes, 'teaser');
unset($viewed['node']['#sorted']);
  $build['sermons'] = $viewed;
}

/**
 * [portico_structure_add_sermons description]
 * @param  [type] &$build [description]
 * @return [type]         [description]
 */
function portico_structure_add_leadership(&$build) {

  $q = new EntityFieldQuery;
  $q->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'person')
    ->propertyCondition('status', NODE_PUBLISHED)
    ->addTag('portico_structure_leadership');

  $r = $q->execute();

  if (empty($r['node'])) {
    return FALSE;
  }

  $nodes = entity_load('node', array_keys($r['node']));

  $viewed = entity_view('node', $nodes, 'teaser');

  $build['leaders'] = array(

    'pastor-elder' => array(
      '#prefix' => '<div class=\'leadership-type\'>',
      'title' => array('#markup' => '<h2>' . t('Pastors and Elders') . '</h2>'),
      '#suffix' => '</div>',
      'people' => array(),
    ),

    'deacon' => array(
      '#prefix' => '<div class=\'leadership-type\'>',
      'title' => array('#markup' => '<h2>' . t('Deacons') . '</h2>'),
      '#suffix' => '</div>',
      'people' => array(),
    ),

    'staff' => array(
      '#prefix' => '<div class=\'leadership-type\'>',
      'title' => array('#markup' => '<h2>' . t('Staff') . '</h2>'),
      '#suffix' => '</div>',
      'people' => array(),
    ),

    '#prefix' => '<div class=\'leadership-wrapper\'>',
    '#suffix' => '</div>',
  );

  // Assign weight, and divy people up by type
  foreach ($nodes as $node) {

    $type = field_get_items('node', $node, 'field_type');
    $type = reset($type);

    $weight = field_get_items('node', $node, 'field_weight');
    $weight = reset($weight);

    $viewed['node'][$node->nid]['#weight'] = $weight['value'];

    $build['leaders'][$type['value']]['people'][] = $viewed['node'][$node->nid];

  }

  // Get rid of unneeded areas if there are any.
  // Also, sort results by field_weight
  foreach ($build['leaders'] as $key => $value) {
    if (empty($value['people'])) {
      unset($build['leaders'][$key]);
      continue;
    }

    uasort($build['leaders'][$key]['people'], 'element_sort');
  }
}
